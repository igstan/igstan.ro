---
title: "Paper: An O(ND) Difference Algorithm"
author: Ionuț G. Stan
date: January 01, 2015
---

I have recently delved into a very deep yak-shaving tree on a personal project...

## Definitions

 - [Edit Graph](#edit-graph)
 - [Match Points and Diagonal Edges](#match-points-and-diagonal-edges)
 - [Paths](#paths)
 - [Traces](#traces)
 - [Subsequences](#subsequences)
 - [Edit Script](#edit-script)
 - [D-paths and Snakes](#d-paths-and-snakes)

### Edit Graph

If we place the two input sequences, one horizontally (say A) and the other (B)
vertically, then draw each element's projection downwards or sidewards, we'll
obtain a grid. Here's a representation using the two example sequences, **abcabba**
and **cbabac**.

If we place the _original_ sequence horizontally, the _modified_ sequence
vertically and then draw straight lines from each element, the lines will
intersect and form a grid like the one bellow.

This grid can be seen as a graph, where the intersection points represent
vertices which divide each corresponding line into graph edges.

<div style="text-align: center;">
  <img src="/files/images/edit-graph.png" alt="Edit Graph">
</div>

This graph is called an _edit_ graph because by giving special meaning to the
two kinds of edges — horizontal and vertical — we can obtain paths that edit, or
transform, the original sequence into the modified one.

In the scheme presented in the paper, where the original sequence is placed
horizontally, horizontal edges mean **delete** and vertical edges mean
**insert**.

Take for example the following path

<div style="text-align: center;">
  <img src="/files/images/edit-path-example-01.png" alt="Edit Path, Example 1">
</div>

The meaning of the above path can be translated into a series of insert and
delete commands, like this:

 - delete(x = 1)
 - delete(x = 2)
 - delete(x = 3)
 - delete(x = 4)
 - delete(x = 5)
 - delete(x = 6)
 - delete(x = 7)
 - insert(x = 7, char = C)
 - insert(x = 7, char = B)
 - insert(x = 7, char = A)
 - insert(x = 7, char = B)
 - insert(x = 7, char = A)
 - insert(x = 7, char = C)

Just for purposes of demonstration, the following path:

<div style="text-align: center;">
  <img src="/files/images/edit-path-example-02.png" alt="Edit Path, Example 2">
</div>

Would be translated to this series of commands:

 - delete(x = 1)
 - insert(x = 1, char = C)
 - delete(x = 2)
 - insert(x = 2, char = B)
 - delete(x = 3)
 - insert(x = 3, char = A)
 - delete(x = 4)
 - insert(x = 4, char = B)
 - delete(x = 5)
 - insert(x = 5, char = A)
 - delete(x = 6)
 - insert(x = 6, char = C)
 - delete(x = 7)

Have you noticed something peculiar about the preceding series of commands? We
have pairs of subsequent operations that cancel each other. For example, we
delete a character just to insert it back again in the subsequent command:

 - delete(x = 2)
 - insert(x = 2, char = B)

This happens for those vertices in the graph located at the intersection of
lines generated by equal characters.

<div style="text-align: center;">
  <p>Delete B</p>
  <img src="/files/images/edit-paths-delete-B.png" alt="Edit Path: Delete B">
</div>

<div style="text-align: center;">
  <p>Insert B</p>
  <img src="/files/images/edit-paths-insert-B.png" alt="Edit Path: Insert B">
</div>

<div style="text-align: center;">
  <p>Insert A</p>
  <img src="/files/images/edit-paths-insert-A.png" alt="Edit Path: Insert A">
</div>

<div style="text-align: center;">
  <p>Delete A</p>
  <img src="/files/images/edit-paths-delete-A.png" alt="Edit Path: Delete A">
</div>

<div style="text-align: center;">
  <p>Insert Second B</p>
  <img src="/files/images/edit-paths-insert-second-B.png" alt="Edit Path: Insert Second B">
</div>

<div style="text-align: center;">
  <p>Delete Second B</p>
  <img src="/files/images/edit-paths-delete-second-B.png" alt="Edit Path: Delete Second B">
</div>

Having made this observation, we can introduce a third type of edges, diagonal
edges. Informally, these can be considered contractions of pairs of edges that
cancel each other, like the ones we've just seen.

Here's the edit graph with highlighted diagonal edges and match points.

<div style="text-align: center;">
  <img src="/files/images/diagonal-edges.png" alt="Edit Graph with Diagonal Edges">
</div>

### Match Points and Diagonal Edges

The intersection points for equal elements are called **match points**. The image
below depicts the same grid, but with highlighted match points.

<div style="text-align: center;">
  <img src="/files/images/match-points.png" alt="Edit Graph with Match Points">
</div>

In addition to horizontal and vertical edges, we can also use diagonal edges
to represent

### Paths
### Traces
### Subsequences
### Edit Script

### Diagonals

<div style="text-align: center;">
  <img src="/files/images/diagonals.png" alt="Edit Graph with Diagonals">
</div>

### D-paths and Snakes

A <dfn>D-Path</dfn> is a path starting from the `(0,0)` vertex which contains
<var>D</var> non-diagonal paths. Here are a few examples:

<div style="text-align: center;">
  <p>A 5-path, ending on k-diagonal -3.</p>
  <img src="/files/images/a-5-path.png" alt="A 5-path">
</div>

<div style="text-align: center;">
  <p>Another 5-path, ending on k-diagonal 1.</p>
  <img src="/files/images/another-5-path.png" alt="Another 5-path">
</div>

Note that there may be many D-paths for a particular value of D (5 in the
example above). They may end on different k-diagonals.

A D-path that ends on a vertex with coordinates greater than any other similar
D-path is called <dfn>furthest reaching</dfn>.

A furthest reaching D-path tries to find the path that takes us closer to the
final answer in the smallest number of steps.

Note that a D-path need not traverse the whole edit graph.

<div style="text-align: center;">
  <p>A 2-path, ending on diagonal 0.</p>
  <img src="/files/images/2-path-version-a.png" alt="2-path, Version A">
</div>

<div style="text-align: center;">
  <p>Another 2-path, ending on diagonal 0.</p>
  <img src="/files/images/2-path-version-b.png" alt="2-path, Version B">
</div>

<div style="text-align: center;">
  <p>A further reaching 2-path, ending on diagonal 0.</p>
  <img src="/files/images/2-path-version-c.png" alt="2-path, Version C">
</div>

<div style="text-align: center;">
  <p>Another further reaching 2-path, ending on diagonal 0.</p>
  <img src="/files/images/2-path-version-d.png" alt="2-path, Version D">
</div>

Informally, a D-path tries to find the path that terminates with the longest
sequence of diagonal edges on the respective k-diagonal. This ending path of
diagonal edges is called a <dfn>snake</dfn>. Any horizontal or vertical edge
that follows the snake of such a D-path will be part of a (D + 1)-path.

## Observations

Now that we're equipped with this taxonomy of concepts about the edit graph, we
can formulate a few observations, prove they are sound and then use them do drive
the final algorithm implementation.

### Observation #1

> A D-path must end on diagonal k ∈ { -D, -D + 2, ... , D - 2, D }.

### Observation #2

> A furthest reaching 0-path ends at (x,x), where x is min(z−1 || az ≠ bz or z > M
> or z > N). A furthest reaching D-path on diagonal k can without loss of
> generality be decomposed into a furthest reaching (D − 1)-path on diagonal k −
> 1, followed by a horizontal edge, followed by the longest possible snake or it
> may be decomposed into a furthest reaching (D − 1)-path on diagonal k + 1,
> followed by a vertical edge, followed by the longest possible snake.

## The Algorithm

Here's the algorithm in pseudo-code, as presented in the paper.

<pre><code><span style="color: #808080;">// Some comment</span>
<b>Constant</b> MAX ∈ [0, M + N]

<b>Var</b> V: <b>Array</b>[-MAX .. MAX] <b>of Integer</b>

V[1] ← 0

<b>For</b> D ← 0 <b>to</b> MAX <b>Do</b>
  <b>For</b> k ← -D <b>to</b> D <b>in steps of</b> 2 <b>Do</b>
    <b>If</b> k = -D <b>or</b> k ≠ D <b>and</b> V[k - 1] &lt; V[k + 1] <b>Then</b>
      x ← V[k + 1]
    <b>Else</b>
      x ← V[k - 1] + 1

    y ← x - k

    <b>While</b> x &lt; N <b>and</b> y &lt; M <b>and</b> a<sub>x + 1</sub> = b<sub>y + 1</sub> <b>Do</b>
      (x, y) ← (x + 1, y + 1)

    V[k] ← x

    <b>If</b> x ≥ N <b>and</b> y ≥ M <b>Then</b>
      <i>Length of an SES is D</i>
      <b>Stop</b>

<i>Length of an SES is greater than MAX</i></code></pre>

This is quite dense and hard to follow for me. Most of the variables use
single-letter names and there are three loop constructs nested one inside the
other, each with different terminating conditions prone to off-by-one errors.

## A Linear Space Refinement

### Lemma 3
